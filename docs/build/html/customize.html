<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Custom Sub-Package &mdash; PyREx 1.10.0 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/searchtools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="about.html" >
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="PyREx 1.10.0 documentation" href="index.html" >
    <link rel="next" title="Example Code" href="examples.html" >
    <link rel="prev" title="How to Use PyREx" href="usage.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" width="250" alt="PyREx" src="_static/logo_white_transparent.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">PyREx 1.10.0 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="examples.html" title="Example Code"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="usage.html" title="How to Use PyREx"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="custom-sub-package">
<span id="custom-package"></span><h1>Custom Sub-Package<a class="headerlink" href="#custom-sub-package" title="Permalink to this headline">¶</a></h1>
<p>While the PyREx package provides a basis for simulation, the real benefits come in customizing the analysis for different purposes. To this end the custom sub-package allows for plug-in style modules to be distributed for different collaborations.</p>
<p>By default PyREx comes with a few custom modules included, listed below. More information about each of these modules can be found in their respective API sections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api/custom-ara.html#custom-ara"><span class="std std-ref">Askaryan Radio Array (pyrex.custom.ara)</span></a></p></li>
<li><p><a class="reference internal" href="api/custom-arianna.html#custom-arianna"><span class="std std-ref">Antarctic Ross Ice-Shelf Antenna Neutrino Array (pyrex.custom.arianna)</span></a></p></li>
<li><p><a class="reference internal" href="api/custom-irex.html#custom-irex"><span class="std std-ref">IceCube Radio Extension (pyrex.custom.irex)</span></a></p></li>
<li><p><a class="reference internal" href="api/custom-layered_ice.html#custom-layered-ice"><span class="std std-ref">Layered Ice Models (pyrex.custom.layered_ice)</span></a></p></li>
</ul>
<p>Other institutions and research groups are encouraged to create their own custom modules to integrate with PyREx. These modules have full access to PyREx as if they were a native part of the package. When PyREx is loaded it automatically scans for these custom modules in certain parts of the filesystem and includes any modules that it can find.
The first place searched is the <code class="docutils literal notranslate"><span class="pre">custom</span></code> directory in the PyREx package itself. Next, if a <code class="docutils literal notranslate"><span class="pre">.pyrex-custom</span></code> directory exists in the user’s home directory (note the leading <code class="docutils literal notranslate"><span class="pre">.</span></code>), its subdirectories are searched for <code class="docutils literal notranslate"><span class="pre">custom</span></code> directories and any modules in these directories are included. Finally, if a <code class="docutils literal notranslate"><span class="pre">pyrex-custom</span></code> directory exists in the current working directory (this time without the leading <code class="docutils literal notranslate"><span class="pre">.</span></code>), its subdirectories are similarly scanned for modules inside <code class="docutils literal notranslate"><span class="pre">custom</span></code> directories. Note that if any name-clashing occurs, the first result found takes precedence (without warning). Additionally, none of these <code class="docutils literal notranslate"><span class="pre">custom</span></code> directories should contain an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file, or else the plug-in system may not work (For more information on the implementation, see PEP 420 and/or David Beazley’s 2015 PyCon talk on Modules and Packages at <a class="reference external" href="https://youtu.be/0oTh1CXRaQ0?t=1h25m45s">https://youtu.be/0oTh1CXRaQ0?t=1h25m45s</a>).</p>
<p>As an example, in the following filesystem layout (which is not meant to reflect the actual current modules available to PyREx) the available custom modules are <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrex.custom.pyspice</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrex.custom.irex</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrex.custom.ara</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrex.custom.arianna</span></code>, and <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrex.custom.my_analysis</span></code>. Additionally note that the name clash for the ARA module will result in the module included in PyREx being loaded and the ARA module in <code class="docutils literal notranslate"><span class="pre">.pyrex-custom</span></code> will be ignored.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/path/to/site-packages/pyrex/
|-- __init__.py
|-- signals.py
|-- antenna.py
|-- ...
|-- custom/
|   |-- pyspice.py
|   |-- irex/
|   |   |-- __init__.py
|   |   |-- antenna.py
|   |   |-- ...
|   |-- ara/
|   |   |-- __init__.py
|   |   |-- antenna.py
|   |   |-- ...

/path/to/home_dir/.pyrex-custom/
|-- ara/
|   |-- custom/
|   |   |-- ara/
|   |   |   |-- __init__.py
|   |   |   |-- antenna.py
|   |   |   |-- ...
|-- arianna/
|   |-- custom/
|   |   |-- arianna/
|   |   |   |-- __init__.py
|   |   |   |-- antenna.py
|   |   |   |-- ...

/path/to/cwd/pyrex-custom/
|-- my_analysis_module/
|   |-- custom/
|   |   |-- my_analysis.py
</pre></div>
</div>
<div class="section" id="build-your-own-custom-module">
<h2>Build Your Own Custom Module<a class="headerlink" href="#build-your-own-custom-module" title="Permalink to this headline">¶</a></h2>
<p>In the course of using PyREx you may wish to change some behavior of parts of the code. Due to the modularity of the code, many behaviors should be customizable by substituting in your own classes inheriting from those already in PyREx. By adding these classes to your own custom module, your code can behave as though it was a native part of the PyREx package. Below the classes which can be easily substituted with your own version are listed, and descriptions of the behavior expected of the classes is outlined.</p>
<div class="section" id="askaryan-signal">
<h3>Askaryan Signal<a class="headerlink" href="#askaryan-signal" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.AskaryanSignal.html#pyrex.AskaryanSignal" title="pyrex.AskaryanSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">AskaryanSignal</span></code></a> class is responsible for storing the time-domain signal of the Askaryan signal produced by a particle shower. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method of an <a class="reference internal" href="docstrings/pyrex.AskaryanSignal.html#pyrex.AskaryanSignal" title="pyrex.AskaryanSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">AskaryanSignal</span></code></a>-like class must accept the arguments listed below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">times</span></code></p></td>
<td><p>A list-type (usually a numpy array) of time values at which to calculate the amplitude of the Askaryan pulse.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">particle</span></code></p></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">Particle</span></code> object representing the neutrino that causes the event. Should have an <code class="docutils literal notranslate"><span class="pre">energy</span></code>, <code class="docutils literal notranslate"><span class="pre">vertex</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code>, and an <code class="docutils literal notranslate"><span class="pre">interaction</span></code> with an <code class="docutils literal notranslate"><span class="pre">em_frac</span></code> and <code class="docutils literal notranslate"><span class="pre">had_frac</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">viewing_angle</span></code></p></td>
<td><p>The viewing angle in radians measured from the shower axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">viewing_distance</span></code></p></td>
<td><p>The distance of the observation point from the shower vertex.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ice</span></code></p></td>
<td><p>The ice model to be used for describing the medium’s index of refraction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">t0</span></code></p></td>
<td><p>The starting time of the Askaryan pulse / showers (default 0).</p></td>
</tr>
</tbody>
</table>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method should result in a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object with <code class="xref py py-attr docutils literal notranslate"><span class="pre">values</span></code> being a numpy array of amplitudes corresponding to the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">times</span></code> and should have a proper <code class="xref py py-attr docutils literal notranslate"><span class="pre">value_type</span></code>. Additionally, all methods of the <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> class should be implemented (typically by just inheriting from <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a>).</p>
</div>
<div class="section" id="antenna-antenna-system">
<h3>Antenna / Antenna System<a class="headerlink" href="#antenna-antenna-system" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal notranslate"><span class="pre">Antenna</span></code></a> class is primarily responsible for receiving and triggering on <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> objects. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method of an <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal notranslate"><span class="pre">Antenna</span></code></a>-like class must accept a <code class="docutils literal notranslate"><span class="pre">position</span></code> argument, and any other arguments may be specified as desired. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method should set the <code class="xref py py-attr docutils literal notranslate"><span class="pre">position</span></code> attribute to the given argument. If not inheriting from <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal notranslate"><span class="pre">Antenna</span></code></a>, the following methods and attributes must be implemented and may require the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method to set some other attributes. <a class="reference internal" href="docstrings/pyrex.AntennaSystem.html#pyrex.AntennaSystem" title="pyrex.AntennaSystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">AntennaSystem</span></code></a>-like classes must expose the same required methods and attributes as <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal notranslate"><span class="pre">Antenna</span></code></a>-like classes, typically by passing calls down to an underlying <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal notranslate"><span class="pre">Antenna</span></code></a>-like object and applying some extra processing.</p>
<p>The <a class="reference internal" href="api/signals.html#module-pyrex.signals" title="pyrex.signals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">signals</span></code></a> attribute should contain a list of all pure <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> objects that the antenna has seen. This is different from the <code class="xref py py-attr docutils literal notranslate"><span class="pre">all_waveforms</span></code> attribute, which should contain a list of all waveform (pure signal + noise) <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> objects the antenna has seen. Yet again different from the <code class="xref py py-attr docutils literal notranslate"><span class="pre">waveforms</span></code> attribute, which should contain only those waveforms which have triggered the antenna.</p>
<p>If using the default <code class="xref py py-attr docutils literal notranslate"><span class="pre">all_waveforms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">waveforms</span></code>, a <code class="xref py py-attr docutils literal notranslate"><span class="pre">_noises</span></code> attribute and <code class="xref py py-attr docutils literal notranslate"><span class="pre">_triggers</span></code> attribute must be initialized to empty lists in <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>. Additionally a <code class="xref py py-meth docutils literal notranslate"><span class="pre">make_noise()</span></code> method must be defined which takes a <code class="docutils literal notranslate"><span class="pre">times</span></code> array and returns a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object with noise amplitudes in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">values</span></code> attribute. If using the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">make_noise()</span></code> method, a <code class="xref py py-attr docutils literal notranslate"><span class="pre">_noise_master</span></code> attribute must be set in <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> to either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object that can generate noise waveforms (setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">_noise_master</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code> and handling noise generation with the attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">freq_range</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">noise_rms</span></code>, or <code class="xref py py-attr docutils literal notranslate"><span class="pre">temperature</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">resistance</span></code>, is recommended).</p>
<p>A <code class="xref py py-meth docutils literal notranslate"><span class="pre">full_waveform()</span></code> method is required which will take a <code class="docutils literal notranslate"><span class="pre">times</span></code> array and return a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object of the waveform the antenna sees at those times. If using the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">full_waveform()</span></code>, a <code class="xref py py-attr docutils literal notranslate"><span class="pre">noisy</span></code> attribute is required which contains a boolean value of whether or not the antenna includes noise in its waveforms. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">noisy</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> then a <code class="xref py py-meth docutils literal notranslate"><span class="pre">make_noise()</span></code> method is also required, as described in the previous paragraph.</p>
<p>An <code class="xref py py-attr docutils literal notranslate"><span class="pre">is_hit</span></code> attribute is required which will be a boolean of whether or not the antenna has been triggered by any waveforms. Similarly an <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_hit_during()</span></code> method is required which will take a <code class="docutils literal notranslate"><span class="pre">times</span></code> array and return a boolean of whether the antenna is triggered during those times.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">trigger()</span></code> method of the antenna should take a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object and return a boolean of whether or not that signal would trigger the antenna.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> method should reset the antenna to a state of having received no signals (i.e. the state just after initialization), and should accept a boolean for <code class="docutils literal notranslate"><span class="pre">reset_noise</span></code> which will force the noise waveforms to be recalculated. If using the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> method, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_noises</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">_triggers</span></code> attributes must be lists.</p>
<p>A <code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code> method is required which will take a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object as <code class="docutils literal notranslate"><span class="pre">signal</span></code>, a 3-vector (list) as <code class="docutils literal notranslate"><span class="pre">direction</span></code>, and a 3-vector (list) as <code class="docutils literal notranslate"><span class="pre">polarization</span></code>. This function doesn’t return anything, but instead processes the input signal and stores it to the <a class="reference internal" href="api/signals.html#module-pyrex.signals" title="pyrex.signals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">signals</span></code></a> list (and anything else needed for the antenna to have officially received the signal). This is the final required method, but if using the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code> method, an <code class="xref py py-attr docutils literal notranslate"><span class="pre">antenna_factor</span></code> attribute is needed to define the conversion from electric field to voltage and an <code class="xref py py-attr docutils literal notranslate"><span class="pre">efficiency</span></code> attribute is required, along with four more methods which must be defined:</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">_convert_to_antenna_coordinates()</span></code> method should take a point in cartesian coordinates and return the <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">theta</span></code>, and <code class="docutils literal notranslate"><span class="pre">phi</span></code> values of that point relative to the antenna. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">directional_gain()</span></code> method should take <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code> in radians and return a (complex) gain based on the directional response of the antenna. Similarly the <code class="xref py py-meth docutils literal notranslate"><span class="pre">polarization_gain()</span></code> method should take a <code class="docutils literal notranslate"><span class="pre">polarization</span></code> 3-vector (list) of an incoming signal and return a (complex) gain based on the polarization response of the antenna. Finally, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">response()</span></code> method should take a list of frequencies and return the (complex) gains of the frequency response of the antenna. This assumes that the directional and frequency responses are separable. If this is not the case then the gains may be better handled with a custom <code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code> method.</p>
</div>
<div class="section" id="detector">
<h3>Detector<a class="headerlink" href="#detector" title="Permalink to this headline">¶</a></h3>
<p>The preferred method of creating your own detector class is to inherit from the <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Detector</span></code></a> class and then implement the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_positions()</span></code> method, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">triggered()</span></code> method, and potentially the <code class="xref py py-meth docutils literal notranslate"><span class="pre">build_antennas()</span></code> method. However the only requirement of a <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Detector</span></code></a>-like object is that iterating over it will visit each antenna exactly once. This means that a simple list of antennas is an acceptable rudimentary detector. The advantages of using the <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Detector</span></code></a> class are easy breaking into subsets (a detector could be made up of stations, which in turn are made up of strings) and the simpler <code class="xref py py-meth docutils literal notranslate"><span class="pre">triggered()</span></code> method for trigger checks.</p>
</div>
<div class="section" id="ice-model">
<h3>Ice Model<a class="headerlink" href="#ice-model" title="Permalink to this headline">¶</a></h3>
<p>Ice model classes are responsible for describing the properties of the ice as functions of depth and frequency. While not explicitly required, all ice model classes in PyREx are defined only with static and class methods, so no <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method is actually necessary. The necessary methods, however, are as follows:</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code> method should take a depth (or numpy array of depths) and return the corresponding index of refraction. Conversely, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">depth_with_index()</span></code> method should take an index of refraction (or numpy array of indices) and return the corresponding depths. In the case of degeneracy here (for example with uniform ice), the recommended behavior is to return the shallowest depth with the given index, though PyREx’s behavior in cases of non-monotonic index functions is not well defined.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">temperature()</span></code> method should take a depth (or numpy array of depths) and return the corresponding ice temperature in Kelvin.</p>
<p>Finally, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">attenuation_length()</span></code> function should take a depth (or numpy array of depths) and a frequency (or numpy array of frequencies) and return the corresponding attenuation length. In the case of one scalar and one array argument, a simple 1D array should be returned. In the case of both arguments being arrays, the return value should be a 2D array where each row represents different frequencies at a single depth and each column represents different depths at a single frequency.</p>
</div>
<div class="section" id="ray-tracer-ray-trace-path">
<h3>Ray Tracer / Ray Trace Path<a class="headerlink" href="#ray-tracer-ray-trace-path" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracer</span></code></a> and <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracePath</span></code></a> classes are responsible for handling ray tracing through the ice between shower vertices and antenna positions. The <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracer</span></code></a> class finds the paths between the two points and the <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracePath</span></code></a> calculates values along the path. Due to the potential for high calculation costs, the PyREx <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracer</span></code></a> and <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracePath</span></code></a> classes inherit from a <code class="xref py py-class docutils literal notranslate"><span class="pre">LazyMutableClass</span></code> which allows the use of a <code class="xref py py-func docutils literal notranslate"><span class="pre">lazy_property()</span></code> decorator to cache results of attribute calculations. It is recommended that any other ray tracing classes consider doing this as well.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method of a <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracer</span></code></a>-like class should take as arguments a 3-vector (list) <code class="docutils literal notranslate"><span class="pre">from_point</span></code>, a 3-vector (list) <code class="docutils literal notranslate"><span class="pre">to_point</span></code>, and an <code class="xref py py-class docutils literal notranslate"><span class="pre">IceModel</span></code>-like <code class="docutils literal notranslate"><span class="pre">ice_model</span></code>. The only required features of the class are a boolean attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">exists</span></code> recording whether or not paths exist between the given points, and an iterable attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">solutions</span></code> which iterates over <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracePath</span></code></a>-like objects between the points.</p>
<p>A <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracePath</span></code></a>-like class will be initialized by a corresponding <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RayTracer</span></code></a>-like object, so there are no requirements on its <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method. The path must have <code class="xref py py-attr docutils literal notranslate"><span class="pre">emitted_direction</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">received_direction</span></code> attributes which are numpy arrays of the cartesian direction the ray is pointing at the <code class="xref py py-attr docutils literal notranslate"><span class="pre">from_point</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">to_point</span></code> of the ray tracer, respectively. The path must also have attributes for the <code class="xref py py-attr docutils literal notranslate"><span class="pre">path_length</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">tof</span></code> (time of flight) along the path.</p>
<p>The path class must have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code> method which takes a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code></a> object as its argument and propagates that signal by applying any attenuation and time of flight. This method does not have a return value. Additionally, note that any 1/R factor that the signal could have is not applied in this method, but externally by dividing the signal values by the <code class="xref py py-attr docutils literal notranslate"><span class="pre">path_length</span></code>. If using the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code> method, an <code class="xref py py-meth docutils literal notranslate"><span class="pre">attenuation()</span></code> method is required which takes an array of frequencies <code class="docutils literal notranslate"><span class="pre">f</span></code> and returns the attenuation factors for a signal along the path at those frequencies.</p>
<p>Finally, though not required it is recommended that the path have a <code class="xref py py-attr docutils literal notranslate"><span class="pre">coordinates</span></code> attribute which is a list of lists of the x, y, and z coordinates along the path (with some reasonable step size). This method is used for plotting purposes and does not need to have the accuracy necessary for calculations.</p>
</div>
<div class="section" id="interaction-model">
<h3>Interaction Model<a class="headerlink" href="#interaction-model" title="Permalink to this headline">¶</a></h3>
<p>The interaction model used for <a class="reference internal" href="docstrings/pyrex.Particle.html#pyrex.Particle" title="pyrex.Particle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particle</span></code></a> interactions in ice handles the cross sections and interaction lengths of neutrinos, as well as the ratios of their interaction types and the resulting shower fractions. An interaction class should inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">Interaction</span></code> (preferably keeping its <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method) and should implement the following methods:</p>
<p>The <code class="xref py py-attr docutils literal notranslate"><span class="pre">cross_section</span></code> property method should return the neutrino cross section for the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Interaction.particle</span></code> parent, specific to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Interaction.kind</span></code>. Similarly the <code class="xref py py-attr docutils literal notranslate"><span class="pre">total_cross_section</span></code> property method should return the neutrino cross section for the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Interaction.particle</span></code> parent, but this should be the total cross section for both charged-current and neutral-current interactions. The <code class="xref py py-attr docutils literal notranslate"><span class="pre">interaction_length</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">total_interaction_length</span></code> properties will convert these cross sections to interaction lengths automatically.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">choose_interaction()</span></code> method should return a value from <code class="xref py py-class docutils literal notranslate"><span class="pre">Interaction.Type</span></code> representing the interaction type based on a random choice. Similarly the <code class="xref py py-meth docutils literal notranslate"><span class="pre">choose_inelasticity()</span></code> method should return an inelasticity value based on a random choice, and the <code class="xref py py-meth docutils literal notranslate"><span class="pre">choose_shower_fractions()</span></code> method return calculate electromagnetic and hadronic fractions based on the <code class="xref py py-attr docutils literal notranslate"><span class="pre">inelasticity</span></code> attribute storing the inelasticity value from <code class="xref py py-meth docutils literal notranslate"><span class="pre">choose_inelasticity()</span></code>. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">choose_shower_fractions()</span></code> can be either chosen based on random processes like secondary generation or deterministic.</p>
</div>
<div class="section" id="particle-generator">
<h3>Particle Generator<a class="headerlink" href="#particle-generator" title="Permalink to this headline">¶</a></h3>
<p>The particle generator classes are quite flexible. The only requirement is that they possess an <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_event()</span></code> method which returns a <a class="reference internal" href="docstrings/pyrex.Event.html#pyrex.Event" title="pyrex.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a> object consisting of at least one <a class="reference internal" href="docstrings/pyrex.Particle.html#pyrex.Particle" title="pyrex.Particle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Particle</span></code></a>. The <code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code> base class provides a solid foundation for basic uniform generators in a volume, requiring only implementation of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_vertex()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_exit_points()</span></code> methods for the specific volume at a minimum.</p>
</div>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyREx</a></h1>



<p class="blurb">A Python package for simulation of neutrinos and radio antennas in ice.
Version 1.10.0</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=bhokansonfasig&repo=pyrex&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div id="searchbox" style="display: none" role="search">
<h3>Quick search</h3>
  <div class="searchformwrapper">
  <form class="search" action="search.html" method="get">
    <input type="text" name="q" />
    <input type="submit" value="Go" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About PyREx</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">How to Use PyREx</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom Sub-Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#build-your-own-custom-module">Build Your Own Custom Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to PyREx</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">PyREx API</a></li>
<li class="toctree-l1"><a class="reference internal" href="versions.html">Version History</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://github.com/bhokansonfasig/pyrex">Source (GitHub)</a></li>
    
    <li class="toctree-l1"><a href="https://github.com/bhokansonfasig/pyrex/issues">Report an Issue</a></li>
    
</ul>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2021, Ben Hokanson-Fasig.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.5.4.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>